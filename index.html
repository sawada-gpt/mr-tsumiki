<!DOCTYPE html>

<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WebXR MRã¤ã¿ãã‚²ãƒ¼ãƒ </title>
    <style>
        body {
            margin: 0;
            padding: 0;
            font-family: 'Arial', sans-serif;
            background: #000;
            color: white;
            overflow: hidden;
        }

```
    #info {
        position: absolute;
        top: 20px;
        left: 20px;
        z-index: 100;
        background: rgba(0, 0, 0, 0.9);
        padding: 20px;
        border-radius: 10px;
        font-size: 16px;
        max-width: 90vw;
        word-wrap: break-word;
    }

    #startButton {
        background: linear-gradient(45deg, #ff6b6b, #ee5a52);
        border: none;
        color: white;
        padding: 15px 30px;
        font-size: 18px;
        font-weight: bold;
        border-radius: 10px;
        cursor: pointer;
        margin: 10px 0;
        transition: all 0.3s ease;
        display: block;
        width: 100%;
    }

    #startButton:hover {
        transform: translateY(-2px);
        box-shadow: 0 6px 20px rgba(255, 107, 107, 0.6);
    }

    #startButton:disabled {
        background: #666;
        cursor: not-allowed;
        opacity: 0.5;
    }

    .status {
        margin: 10px 0;
        padding: 15px;
        border-radius: 5px;
        background: rgba(255, 255, 255, 0.1);
        font-size: 14px;
        line-height: 1.4;
    }

    .error {
        background: rgba(255, 0, 0, 0.3);
    }

    .success {
        background: rgba(0, 255, 0, 0.3);
    }

    #canvas {
        display: block;
        width: 100vw;
        height: 100vh;
    }

    .hand-ui {
        position: absolute;
        background: rgba(0, 0, 0, 0.7);
        color: white;
        padding: 10px;
        border-radius: 5px;
        font-size: 12px;
        pointer-events: none;
        transform: translate(-50%, -100%);
        margin-top: -10px;
    }
</style>
```

</head>
<body>
    <div id="info">
        <h2>WebXR MRã¤ã¿ãã‚²ãƒ¼ãƒ </h2>
        <button id="startButton">MRã‚»ãƒƒã‚·ãƒ§ãƒ³é–‹å§‹</button>
        <button id="debugButton" style="background: #666; margin-top: 10px;">ğŸ“± ã‚¹ãƒãƒ›ãƒ‡ãƒãƒƒã‚°</button>
        <div id="status" class="status">MRãƒ‡ãƒã‚¤ã‚¹ã‚’ç¢ºèªä¸­...</div>
        <div id="instructions">
            <strong>æ“ä½œæ–¹æ³•ï¼ˆMRãƒ¢ãƒ¼ãƒ‰ï¼‰:</strong><br>
            â€¢ ãƒãƒ³ãƒ‰ãƒˆãƒ©ãƒƒã‚­ãƒ³ã‚°: ã¤ã¾ã¿å‹•ä½œã§ã¤ã¿ãã‚’æ´ã‚€<br>
            â€¢ ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ©ãƒ¼: ãƒˆãƒªã‚¬ãƒ¼ãƒœã‚¿ãƒ³ã§é¸æŠ<br>
            â€¢ éŸ³å£°: "ã¤ã¿ã" ã§ã¤ã¿ãç”Ÿæˆ<br>
            â€¢ éŸ³å£°: "ãƒªã‚»ãƒƒãƒˆ" ã§ãƒªã‚»ãƒƒãƒˆ<br>
            â€¢ ç¾å®Ÿã®æœºã‚„åºŠã«é…ç½®ã§ãã¾ã™
        </div>
    </div>

```
<canvas id="canvas"></canvas>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script>
    class WebXRBlockGame {
        constructor() {
            this.scene = new THREE.Scene();
            this.camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            this.renderer = new THREE.WebGLRenderer({ 
                canvas: document.getElementById('canvas'),
                antialias: true,
                alpha: true
            });
            
            this.xrSession = null;
            this.xrReferenceSpace = null;
            this.controllers = [];
            this.hands = [];
            this.blocks = [];
            this.selectedBlock = null;
            this.isXRSupported = false;
            
            // éŸ³å£°èªè­˜
            this.speechRecognition = null;
            this.isListening = false;
            
            // ç©ºé–“ãƒãƒƒãƒ”ãƒ³ã‚°ç”¨
            this.planes = [];
            this.anchors = [];
            
            // ã¤ã¿ããƒœãƒƒã‚¯ã‚¹
            this.spawnBox = null;
            
            this.blockTypes = [
                { name: 'ç«‹æ–¹ä½“', color: 0xff6b6b, size: [0.05, 0.05, 0.05] }, // MRã‚¹ã‚±ãƒ¼ãƒ«ï¼ˆãƒ¡ãƒ¼ãƒˆãƒ«å˜ä½ï¼‰
                { name: 'ç›´æ–¹ä½“', color: 0x4ecdc4, size: [0.08, 0.03, 0.05] },
                { name: 'ç´°é•·', color: 0x45b7d1, size: [0.12, 0.03, 0.03] },
                { name: 'å¹³æ¿', color: 0x96ceb4, size: [0.08, 0.02, 0.08] },
                { name: 'é«˜ã„', color: 0xffeaa7, size: [0.04, 0.1, 0.04] },
                { name: 'Lå­—', color: 0xdda0dd, size: [0.06, 0.05, 0.05] }
            ];
            
            this.init();
        }
        
        async init() {
            // WebXRã‚µãƒãƒ¼ãƒˆç¢ºèª
            await this.checkXRSupport();
            
            // ãƒ¬ãƒ³ãƒ€ãƒ©ãƒ¼ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—
            this.renderer.setSize(window.innerWidth, window.innerHeight);
            this.renderer.shadowMap.enabled = true;
            this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            this.renderer.xr.enabled = true;
            
            // ãƒ©ã‚¤ãƒ†ã‚£ãƒ³ã‚°
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.4);
            this.scene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(0.5, 1, 0.5);
            directionalLight.castShadow = true;
            directionalLight.shadow.mapSize.width = 1024;
            directionalLight.shadow.mapSize.height = 1024;
            this.scene.add(directionalLight);
            
            // ã¤ã¿ãç”Ÿæˆãƒœãƒƒã‚¯ã‚¹
            this.createSpawnBox();
            
            // ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ©ãƒ¼ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—
            this.setupControllers();
            
            // ãƒãƒ³ãƒ‰ãƒˆãƒ©ãƒƒã‚­ãƒ³ã‚°ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—
            this.setupHandTracking();
            
            // éŸ³å£°èªè­˜ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—
            this.setupSpeechRecognition();
            
            // UIã‚¤ãƒ™ãƒ³ãƒˆ
            document.getElementById('startButton').addEventListener('click', () => this.startXRSession());
            
            window.addEventListener('resize', () => this.onWindowResize());
            
            // ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ãƒ«ãƒ¼ãƒ—
            this.renderer.setAnimationLoop(() => this.animate());
        }
        
        async checkXRSupport() {
            let debugInfo = '';
            
            if ('xr' in navigator) {
                try {
                    debugInfo += 'WebXR APIæ¤œå‡ºä¸­...\n';
                    const isSupported = await navigator.xr.isSessionSupported('immersive-ar');
                    this.isXRSupported = isSupported;
                    
                    debugInfo += `WebXR VRã‚µãƒãƒ¼ãƒˆ: ${isSupported}\n`;
                    
                    if (isSupported) {
                        document.getElementById('status').innerHTML = 'MRå¯¾å¿œãƒ‡ãƒã‚¤ã‚¹ãŒæ¤œå‡ºã•ã‚Œã¾ã—ãŸ<br><small>' + debugInfo + '</small>';
                        document.getElementById('status').className = 'status success';
                        document.getElementById('startButton').disabled = false;
                    } else {
                        document.getElementById('status').innerHTML = 'MRãƒ¢ãƒ¼ãƒ‰ã¯åˆ©ç”¨ã§ãã¾ã›ã‚“<br><small>' + debugInfo + '</small>';
                        document.getElementById('status').className = 'status error';
                        document.getElementById('startButton').disabled = true;
                    }
                } catch (error) {
                    debugInfo += `WebXRç¢ºèªã‚¨ãƒ©ãƒ¼: ${error.message}\n`;
                    document.getElementById('status').innerHTML = 'WebXRç¢ºèªã‚¨ãƒ©ãƒ¼<br><small>' + debugInfo + '</small>';
                    document.getElementById('status').className = 'status error';
                    document.getElementById('startButton').disabled = true;
                }
            } else {
                debugInfo += 'WebXR API ãŒåˆ©ç”¨ã§ãã¾ã›ã‚“\n';
                document.getElementById('status').innerHTML = 'ã“ã®ãƒ–ãƒ©ã‚¦ã‚¶ã¯WebXRã«å¯¾å¿œã—ã¦ã„ã¾ã›ã‚“<br><small>' + debugInfo + '</small>';
                document.getElementById('status').className = 'status error';
                document.getElementById('startButton').disabled = true;
            }
        }
        
        async startXRSession() {
            let debugInfo = 'VRã‚»ãƒƒã‚·ãƒ§ãƒ³é–‹å§‹ã‚’è©¦è¡Œä¸­...\n';
            
            if (!this.isXRSupported) {
                alert('VRã‚»ãƒƒã‚·ãƒ§ãƒ³ã‚’é–‹å§‹ã§ãã¾ã›ã‚“ã€‚WebXRå¯¾å¿œãƒ‡ãƒã‚¤ã‚¹ãŒå¿…è¦ã§ã™ã€‚');
                return;
            }
            
            try {
                document.getElementById('startButton').disabled = true;
                document.getElementById('status').innerHTML = 'VRã‚»ãƒƒã‚·ãƒ§ãƒ³ã‚’é–‹å§‹ã—ã¦ã„ã¾ã™...<br><small>' + debugInfo + '</small>';
                
                debugInfo += 'navigator.xr.requestSessionå®Ÿè¡Œä¸­...\n';
                
                // VR ã‚»ãƒƒã‚·ãƒ§ãƒ³ã‚’è¦æ±‚
                this.xrSession = await navigator.xr.requestSession('immersive-vr', {
                    requiredFeatures: ['local'],
                    optionalFeatures: ['local-floor', 'hand-tracking']
                });
                
                debugInfo += 'VRã‚»ãƒƒã‚·ãƒ§ãƒ³å–å¾—æˆåŠŸ\n';
                
                // XRã‚»ãƒƒã‚·ãƒ§ãƒ³è¨­å®š
                await this.renderer.xr.setSession(this.xrSession);
                
                // å‚ç…§ç©ºé–“ã‚’å–å¾—
                this.xrReferenceSpace = await this.xrSession.requestReferenceSpace('local');
                
                // ã‚»ãƒƒã‚·ãƒ§ãƒ³ã‚¤ãƒ™ãƒ³ãƒˆ
                this.xrSession.addEventListener('end', () => this.onSessionEnd());
                
                document.getElementById('status').innerHTML = 'VRã‚»ãƒƒã‚·ãƒ§ãƒ³é–‹å§‹ï¼<br><small>VRç©ºé–“ã§ã¤ã¿ãã‚²ãƒ¼ãƒ ã‚’æ¥½ã—ã‚“ã§ãã ã•ã„</small>';
                document.getElementById('status').className = 'status success';
                
                // éŸ³å£°èªè­˜é–‹å§‹
                this.startSpeechRecognition();
                
            } catch (error) {
                debugInfo += `ã‚¨ãƒ©ãƒ¼: ${error.name} - ${error.message}\n`;
                document.getElementById('status').innerHTML = 'VRã‚»ãƒƒã‚·ãƒ§ãƒ³é–‹å§‹ã‚¨ãƒ©ãƒ¼<br><small>' + debugInfo + '</small>';
                document.getElementById('status').className = 'status error';
                document.getElementById('startButton').disabled = false;
            }
        }
        
        createSpawnBox() {
            const boxGeometry = new THREE.BoxGeometry(0.1, 0.075, 0.1);
            const boxMaterial = new THREE.MeshLambertMaterial({ 
                color: 0x8b4513,
                transparent: true,
                opacity: 0.8
            });
            this.spawnBox = new THREE.Mesh(boxGeometry, boxMaterial);
            this.spawnBox.position.set(0, 0, -0.3); // ãƒ¦ãƒ¼ã‚¶ãƒ¼ã®å‰æ–¹30cm
            this.spawnBox.castShadow = true;
            this.scene.add(this.spawnBox);
            
            // ãƒœãƒƒã‚¯ã‚¹ã®è“‹
            const lidGeometry = new THREE.BoxGeometry(0.11, 0.005, 0.11);
            const lidMaterial = new THREE.MeshLambertMaterial({ color: 0x654321 });
            this.lid = new THREE.Mesh(lidGeometry, lidMaterial);
            this.lid.position.set(0, 0.04, -0.3);
            this.scene.add(this.lid);
            
            // ãƒœãƒƒã‚¯ã‚¹ã®ãƒ©ãƒ™ãƒ«
            this.createBoxLabel();
        }
        
        createBoxLabel() {
            const canvas = document.createElement('canvas');
            const context = canvas.getContext('2d');
            canvas.width = 256;
            canvas.height = 128;
            
            context.fillStyle = '#ffffff';
            context.fillRect(0, 0, 256, 128);
            context.fillStyle = '#000000';
            context.font = '24px Arial';
            context.textAlign = 'center';
            context.fillText('ã¤ã¿ã BOX', 128, 50);
            context.font = '16px Arial';
            context.fillText('ã¤ã¾ã‚“ã§é–‹ã‘ã‚ˆã†ï¼', 128, 80);
            
            const texture = new THREE.CanvasTexture(canvas);
            const labelMaterial = new THREE.MeshBasicMaterial({ map: texture });
            const labelGeometry = new THREE.PlaneGeometry(0.08, 0.04);
            const label = new THREE.Mesh(labelGeometry, labelMaterial);
            label.position.set(0, 0.05, -0.25);
            this.scene.add(label);
        }
        
        setupControllers() {
            const controllerModelFactory = new THREE.XRControllerModelFactory();
            
            for (let i = 0; i < 2; i++) {
                // ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ©ãƒ¼
                const controller = this.renderer.xr.getController(i);
                controller.addEventListener('selectstart', (event) => this.onControllerSelectStart(event, i));
                controller.addEventListener('selectend', (event) => this.onControllerSelectEnd(event, i));
                controller.addEventListener('squeeze', (event) => this.onControllerSqueeze(event, i));
                this.scene.add(controller);
                
                // ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ©ãƒ¼ãƒ¢ãƒ‡ãƒ«
                const controllerGrip = this.renderer.xr.getControllerGrip(i);
                controllerGrip.add(controllerModelFactory.createControllerModel(controllerGrip));
                this.scene.add(controllerGrip);
                
                // ãƒ¬ãƒ¼ã‚¶ãƒ¼ãƒã‚¤ãƒ³ã‚¿ãƒ¼
                const geometry = new THREE.BufferGeometry().setFromPoints([
                    new THREE.Vector3(0, 0, 0),
                    new THREE.Vector3(0, 0, -1)
                ]);
                const line = new THREE.Line(geometry, new THREE.LineBasicMaterial({ color: 0xff0000 }));
                line.name = 'line';
                line.scale.z = 0.1;
                controller.add(line);
                
                this.controllers.push({
                    controller: controller,
                    grip: controllerGrip,
                    isSelecting: false
                });
            }
        }
        
        setupHandTracking() {
            if ('XRHand' in window) {
                for (let i = 0; i < 2; i++) {
                    const hand = this.renderer.xr.getHand(i);
                    hand.userData.isSelecting = false;
                    
                    // ãƒãƒ³ãƒ‰ãƒ¢ãƒ‡ãƒ«
                    const handModel = new THREE.XRHandModelFactory().createHandModel(hand, 'mesh');
                    hand.add(handModel);
                    
                    this.scene.add(hand);
                    this.hands.push(hand);
                }
            }
        }
        
        setupSpeechRecognition() {
            if ('webkitSpeechRecognition' in window || 'SpeechRecognition' in window) {
                const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
                this.speechRecognition = new SpeechRecognition();
                this.speechRecognition.lang = 'ja-JP';
                this.speechRecognition.continuous = true;
                this.speechRecognition.interimResults = false;
                
                this.speechRecognition.onresult = (event) => {
                    const command = event.results[event.results.length - 1][0].transcript.toLowerCase();
                    this.processSpeechCommand(command);
                };
                
                this.speechRecognition.onerror = (event) => {
                    console.warn('éŸ³å£°èªè­˜ã‚¨ãƒ©ãƒ¼:', event.error);
                };
            }
        }
        
        startSpeechRecognition() {
            if (this.speechRecognition && !this.isListening) {
                this.speechRecognition.start();
                this.isListening = true;
            }
        }
        
        processSpeechCommand(command) {
            console.log('éŸ³å£°ã‚³ãƒãƒ³ãƒ‰:', command);
            
            if (command.includes('ã¤ã¿ã') || command.includes('ãƒ–ãƒ­ãƒƒã‚¯')) {
                this.spawnBlock();
            } else if (command.includes('ãƒªã‚»ãƒƒãƒˆ') || command.includes('ã‚¯ãƒªã‚¢')) {
                this.resetBlocks();
            } else if (command.includes('å¤§ãã„')) {
                this.spawnLargerBlock();
            } else if (command.includes('å°ã•ã„')) {
                this.spawnSmallerBlock();
            }
        }
        
        onControllerSelectStart(event, controllerIndex) {
            const controller = this.controllers[controllerIndex];
            controller.isSelecting = true;
            
            // ãƒ–ãƒ­ãƒƒã‚¯é¸æŠ
            this.selectBlockWithRaycaster(controller.controller);
        }
        
        onControllerSelectEnd(event, controllerIndex) {
            const controller = this.controllers[controllerIndex];
            controller.isSelecting = false;
            
            if (this.selectedBlock) {
                this.releaseSelectedBlock();
            }
        }
        
        onControllerSqueeze(event, controllerIndex) {
            // ã‚¹ã‚¯ã‚¤ãƒ¼ã‚ºã§ã¤ã¿ãç”Ÿæˆ
            this.spawnBlock();
        }
        
        selectBlockWithRaycaster(controller) {
            const tempMatrix = new THREE.Matrix4();
            tempMatrix.identity().extractRotation(controller.matrixWorld);
            
            const raycaster = new THREE.Raycaster();
            raycaster.ray.origin.setFromMatrixPosition(controller.matrixWorld);
            raycaster.ray.direction.set(0, 0, -1).applyMatrix4(tempMatrix);
            
            const intersects = raycaster.intersectObjects(this.blocks);
            
            if (intersects.length > 0) {
                this.selectedBlock = intersects[0].object;
                this.selectedBlock.material.emissive.setHex(0x444444);
                
                // é¸æŠãƒ•ã‚£ãƒ¼ãƒ‰ãƒãƒƒã‚¯ï¼ˆãƒã‚¤ãƒ–ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ï¼‰
                if (controller.gamepad && controller.gamepad.hapticActuators) {
                    controller.gamepad.hapticActuators[0].pulse(0.5, 100);
                }
            }
        }
        
        spawnBlock() {
            const blockType = this.blockTypes[Math.floor(Math.random() * this.blockTypes.length)];
            
            const geometry = new THREE.BoxGeometry(blockType.size[0], blockType.size[1], blockType.size[2]);
            const material = new THREE.MeshLambertMaterial({ color: blockType.color });
            
            const block = new THREE.Mesh(geometry, material);
            
            // ãƒœãƒƒã‚¯ã‚¹ã‹ã‚‰å‡ºç¾
            block.position.copy(this.spawnBox.position);
            block.position.y += 0.1 + Math.random() * 0.05;
            block.position.x += (Math.random() - 0.5) * 0.02;
            block.position.z += (Math.random() - 0.5) * 0.02;
            
            block.rotation.set(
                Math.random() * 0.2,
                Math.random() * Math.PI,
                Math.random() * 0.2
            );
            
            block.castShadow = true;
            block.receiveShadow = true;
            block.userData = { 
                velocity: new THREE.Vector3(
                    (Math.random() - 0.5) * 0.001,
                    -0.0005,
                    (Math.random() - 0.5) * 0.001
                ),
                size: blockType.size,
                isPhysicsEnabled: true
            };
            
            this.scene.add(block);
            this.blocks.push(block);
            
            // è“‹ã®ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³
            this.animateLid();
            
            // è§¦è¦šãƒ•ã‚£ãƒ¼ãƒ‰ãƒãƒƒã‚¯
            this.triggerHapticFeedback();
        }
        
        spawnLargerBlock() {
            const blockType = {
                name: 'å¤§ãã„ãƒ–ãƒ­ãƒƒã‚¯',
                color: 0xff9999,
                size: [0.08, 0.08, 0.08]
            };
            this.spawnCustomBlock(blockType);
        }
        
        spawnSmallerBlock() {
            const blockType = {
                name: 'å°ã•ã„ãƒ–ãƒ­ãƒƒã‚¯',
                color: 0x99ff99,
                size: [0.02, 0.02, 0.02]
            };
            this.spawnCustomBlock(blockType);
        }
        
        spawnCustomBlock(blockType) {
            const geometry = new THREE.BoxGeometry(blockType.size[0], blockType.size[1], blockType.size[2]);
            const material = new THREE.MeshLambertMaterial({ color: blockType.color });
            
            const block = new THREE.Mesh(geometry, material);
            block.position.copy(this.spawnBox.position);
            block.position.y += 0.1;
            
            block.castShadow = true;
            block.receiveShadow = true;
            block.userData = { 
                size: blockType.size,
                isPhysicsEnabled: true
            };
            
            this.scene.add(block);
            this.blocks.push(block);
        }
        
        animateLid() {
            const originalY = this.lid.position.y;
            const targetY = originalY + 0.02;
            
            let startTime = null;
            const duration = 500;
            
            const animate = (timestamp) => {
                if (!startTime) startTime = timestamp;
                const elapsed = timestamp - startTime;
                const progress = Math.min(elapsed / duration, 1);
                
                if (progress < 0.5) {
                    this.lid.position.y = originalY + (targetY - originalY) * (progress * 2);
                } else {
                    this.lid.position.y = targetY - (targetY - originalY) * ((progress - 0.5) * 2);
                }
                
                if (progress < 1) {
                    requestAnimationFrame(animate);
                } else {
                    this.lid.position.y = originalY;
                }
            };
            
            requestAnimationFrame(animate);
        }
        
        triggerHapticFeedback() {
            // ã™ã¹ã¦ã®ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ©ãƒ¼ã«è§¦è¦šãƒ•ã‚£ãƒ¼ãƒ‰ãƒãƒƒã‚¯
            this.controllers.forEach(controller => {
                if (controller.controller.gamepad && controller.controller.gamepad.hapticActuators) {
                    controller.controller.gamepad.hapticActuators[0].pulse(0.3, 200);
                }
            });
        }
        
        updateHandTracking() {
            this.hands.forEach((hand, index) => {
                if (hand.joints && hand.joints['index-finger-tip'] && hand.joints['thumb-tip']) {
                    const indexTip = hand.joints['index-finger-tip'];
                    const thumbTip = hand.joints['thumb-tip'];
                    
                    if (indexTip.visible && thumbTip.visible) {
                        const distance = indexTip.position.distanceTo(thumbTip.position);
                        
                        // ã¤ã¾ã¿å‹•ä½œã®æ¤œå‡º
                        if (distance < 0.02 && !hand.userData.isSelecting) {
                            hand.userData.isSelecting = true;
                            this.selectBlockWithHand(hand, indexTip.position);
                        } else if (distance > 0.03 && hand.userData.isSelecting) {
                            hand.userData.isSelecting = false;
                            this.releaseSelectedBlock();
                        }
                        
                        // é¸æŠä¸­ã®ãƒ–ãƒ­ãƒƒã‚¯ã‚’æ‰‹ã®ä½ç½®ã«è¿½å¾“
                        if (this.selectedBlock && hand.userData.isSelecting) {
                            const midPoint = new THREE.Vector3()
                                .addVectors(indexTip.position, thumbTip.position)
                                .multiplyScalar(0.5);
                            this.selectedBlock.position.copy(midPoint);
                        }
                    }
                }
            });
        }
        
        selectBlockWithHand(hand, position) {
            let closestBlock = null;
            let closestDistance = Infinity;
            
            this.blocks.forEach(block => {
                const distance = block.position.distanceTo(position);
                if (distance < closestDistance && distance < 0.05) {
                    closestDistance = distance;
                    closestBlock = block;
                }
            });
            
            if (closestBlock) {
                this.selectedBlock = closestBlock;
                this.selectedBlock.material.emissive.setHex(0x444444);
            }
        }
        
        releaseSelectedBlock() {
            if (this.selectedBlock) {
                this.selectedBlock.material.emissive.setHex(0x000000);
                this.selectedBlock = null;
            }
        }
        
        // ç°¡æ˜“ç‰©ç†æ¼”ç®—
        updatePhysics() {
            this.blocks.forEach(block => {
                if (block === this.selectedBlock) return;
                if (!block.userData.isPhysicsEnabled) return;
                
                const velocity = block.userData.velocity;
                if (!velocity) return;
                
                // é‡åŠ›é©ç”¨
                velocity.y -= 0.0001;
                
                // ä½ç½®æ›´æ–°
                block.position.add(velocity);
                
                // åºŠã¨ã®è¡çªï¼ˆç°¡æ˜“ï¼‰
                if (block.position.y < block.userData.size[1] / 2) {
                    block.position.y = block.userData.size[1] / 2;
                    velocity.y = 0;
                    velocity.multiplyScalar(0.9); // æ‘©æ“¦
                }
            });
        }
        
        resetBlocks() {
            this.blocks.forEach(block => {
                this.scene.remove(block);
            });
            this.blocks = [];
            this.selectedBlock = null;
            
            // è§¦è¦šãƒ•ã‚£ãƒ¼ãƒ‰ãƒãƒƒã‚¯
            this.triggerHapticFeedback();
        }
        
        animate() {
            if (this.xrSession) {
                // XRãƒ¢ãƒ¼ãƒ‰æ™‚ã®æ›´æ–°
                this.updateHandTracking();
                this.updatePhysics();
                
                // é¸æŠä¸­ã®ãƒ–ãƒ­ãƒƒã‚¯ã‚’ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ©ãƒ¼ã«è¿½å¾“
                if (this.selectedBlock) {
                    this.controllers.forEach(controller => {
                        if (controller.isSelecting) {
                            this.selectedBlock.position.setFromMatrixPosition(controller.controller.matrixWorld);
                            this.selectedBlock.position.z -= 0.1; // å°‘ã—å‰æ–¹ã«é…ç½®
                        }
                    });
                }
            }
            
            this.renderer.render(this.scene, this.camera);
        }
        
        onSessionEnd() {
            this.xrSession = null;
            document.getElementById('startButton').disabled = false;
            document.getElementById('status').textContent = 'MRã‚»ãƒƒã‚·ãƒ§ãƒ³ãŒçµ‚äº†ã—ã¾ã—ãŸ';
            document.getElementById('status').className = 'status';
            
            if (this.speechRecognition && this.isListening) {
                this.speechRecognition.stop();
                this.isListening = false;
            }
        }
        
        showDebugInfo() {
            let debugText = '=== WebXR ãƒ‡ãƒãƒƒã‚°æƒ…å ± ===\n';
            debugText += `ãƒ¦ãƒ¼ã‚¶ãƒ¼ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆ: ${navigator.userAgent}\n\n`;
            debugText += `WebXRå¯¾å¿œ: ${'xr' in navigator ? 'ã‚ã‚Š' : 'ãªã—'}\n`;
            debugText += `ARã‚µãƒãƒ¼ãƒˆ: ${this.isXRSupported ? 'ã‚ã‚Š' : 'ãªã—'}\n\n`;
            
            if ('xr' in navigator) {
                navigator.xr.isSessionSupported('immersive-ar').then(supported => {
                    debugText += `ARã‚»ãƒƒã‚·ãƒ§ãƒ³å¯¾å¿œ: ${supported ? 'ã‚ã‚Š' : 'ãªã—'}\n`;
                    alert(debugText);
                }).catch(error => {
                    debugText += `ARãƒã‚§ãƒƒã‚¯ã‚¨ãƒ©ãƒ¼: ${error.message}\n`;
                    alert(debugText);
                });
            } else {
                alert(debugText);
            }
        }
        
        onWindowResize() {
            this.camera.aspect = window.innerWidth / window.innerHeight;
            this.camera.updateProjectionMatrix();
            this.renderer.setSize(window.innerWidth, window.innerHeight);
        }
    }
    
    // ã‚²ãƒ¼ãƒ é–‹å§‹
    window.addEventListener('load', () => {
        new WebXRBlockGame();
    });
</script>
```

</body>
</html>